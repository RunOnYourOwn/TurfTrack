name: CI

on:
  push:
    branches:
      - main
    paths-ignore:
      - 'docs/**'
      - '.claude/**'
      - '*.md'
  pull_request:
    branches:
      - main
    paths-ignore:
      - 'docs/**'
      - '.claude/**'
      - '*.md'

# Cancel in-progress runs when a new commit is pushed to the same branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Run Go unit tests
  test-go:
    runs-on: [self-hosted, Linux]
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Pre-checkout cleanup
        run: |
          echo "Cleaning workspace before checkout..."
          rm -rf $GITHUB_WORKSPACE/* || true
          rm -rf $GITHUB_WORKSPACE/.git || true

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: false  # Disable built-in cache on self-hosted runner

      - name: Run Go unit tests with coverage
        working-directory: go-app
        run: |
          set -o pipefail
          go test ./... -race -count=1 -coverprofile=coverage.out -covermode=atomic -v 2>&1 | tee test-output.txt

      - name: Generate test summary
        if: always()
        working-directory: go-app
        run: |
          TOTAL_COVERAGE=$(go tool cover -func=coverage.out 2>/dev/null | grep "^total:" | awk '{print $NF}' || echo "N/A")

          # Count test results more robustly - grep returns count, handle empty/error cases
          TEST_PASSED=$(grep -c "^--- PASS:" test-output.txt 2>/dev/null || echo 0)
          TEST_PASSED=${TEST_PASSED:-0}
          TEST_PASSED=$(echo "$TEST_PASSED" | tr -d '[:space:]' | head -c 10)

          TEST_FAILED=$(grep -c "^--- FAIL:" test-output.txt 2>/dev/null || echo 0)
          TEST_FAILED=${TEST_FAILED:-0}
          TEST_FAILED=$(echo "$TEST_FAILED" | tr -d '[:space:]' | head -c 10)

          # Ensure we have valid integers
          [[ "$TEST_PASSED" =~ ^[0-9]+$ ]] || TEST_PASSED=0
          [[ "$TEST_FAILED" =~ ^[0-9]+$ ]] || TEST_FAILED=0

          SUMMARY="## Go Test Results\n\n"

          if [ "$TEST_FAILED" -gt 0 ]; then
            SUMMARY+=":x: **${TEST_PASSED} passed, ${TEST_FAILED} failed** | Coverage: ${TOTAL_COVERAGE}\n"
          else
            SUMMARY+=":white_check_mark: **${TEST_PASSED} passed** | Coverage: ${TOTAL_COVERAGE}\n"
          fi

          SUMMARY+="\n| Package | Coverage |\n"
          SUMMARY+="|---------|----------|\n"

          # Parse per-package coverage from test output (lines like: "ok  pkg  1.2s  coverage: 84.3% of statements")
          while IFS= read -r line; do
            PKG=$(echo "$line" | awk '{print $2}')
            COV=$(echo "$line" | grep -o 'coverage: [0-9.]*%' | grep -o '[0-9.]*%')
            if [ -n "$COV" ]; then
              SHORT=$(echo "$PKG" | sed 's|github.com/RunOnYourOwn/TurfTrack/go-app/||')
              SUMMARY+="| \`${SHORT}\` | ${COV} |\n"
            fi
          done < <(grep "^ok" test-output.txt 2>/dev/null)

          printf '%b' "$SUMMARY" >> $GITHUB_STEP_SUMMARY

      - name: Run Go lint
        uses: golangci/golangci-lint-action@v6
        with:
          working-directory: go-app
          version: latest
          install-mode: goinstall

      - name: Build Go binary
        working-directory: go-app
        run: |
          CGO_ENABLED=0 go build -o /dev/null ./cmd/server

      - name: Cleanup workspace
        if: always()
        run: rm -rf $GITHUB_WORKSPACE/*

  # Run Go integration tests
  test-integration:
    runs-on: [self-hosted, Linux]
    permissions:
      contents: read
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: turftrack
          POSTGRES_PASSWORD: turftrack
          POSTGRES_DB: turftrack_test
        ports:
          - 5432:5432
        options: --health-cmd="pg_isready -U turftrack -d turftrack_test" --health-interval=5s --health-timeout=5s --health-retries=5
    env:
      TEST_DATABASE_URL: "host=localhost port=5432 user=turftrack password=turftrack dbname=turftrack_test sslmode=disable"
    steps:
      - name: Pre-checkout cleanup
        run: |
          echo "Cleaning workspace before checkout..."
          rm -rf $GITHUB_WORKSPACE/* || true
          rm -rf $GITHUB_WORKSPACE/.git || true

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: false

      - name: Run integration tests
        working-directory: go-app
        run: |
          set -o pipefail
          go test ./... -tags integration -race -count=1 -p 1 -coverprofile=integration-coverage.out -covermode=atomic -v 2>&1 | tee integration-test-output.txt

      - name: Generate integration test summary
        if: always()
        working-directory: go-app
        run: |
          TEST_PASSED=$(grep -c "^--- PASS:" integration-test-output.txt 2>/dev/null || echo 0)
          TEST_PASSED=${TEST_PASSED:-0}
          TEST_PASSED=$(echo "$TEST_PASSED" | tr -d '[:space:]' | head -c 10)

          TEST_FAILED=$(grep -c "^--- FAIL:" integration-test-output.txt 2>/dev/null || echo 0)
          TEST_FAILED=${TEST_FAILED:-0}
          TEST_FAILED=$(echo "$TEST_FAILED" | tr -d '[:space:]' | head -c 10)

          [[ "$TEST_PASSED" =~ ^[0-9]+$ ]] || TEST_PASSED=0
          [[ "$TEST_FAILED" =~ ^[0-9]+$ ]] || TEST_FAILED=0

          TOTAL_COVERAGE=$(go tool cover -func=integration-coverage.out 2>/dev/null | grep "^total:" | awk '{print $NF}' || echo "N/A")

          SUMMARY="## Integration Test Results\n\n"

          if [ "$TEST_FAILED" -gt 0 ]; then
            SUMMARY+=":x: **${TEST_PASSED} passed, ${TEST_FAILED} failed** | Coverage: ${TOTAL_COVERAGE}\n"
          else
            SUMMARY+=":white_check_mark: **${TEST_PASSED} passed** | Coverage: ${TOTAL_COVERAGE}\n"
          fi

          SUMMARY+="\n| Package | Coverage |\n"
          SUMMARY+="|---------|----------|\n"

          while IFS= read -r line; do
            PKG=$(echo "$line" | awk '{print $2}')
            COV=$(echo "$line" | grep -o 'coverage: [0-9.]*%' | grep -o '[0-9.]*%')
            if [ -n "$COV" ]; then
              SHORT=$(echo "$PKG" | sed 's|github.com/RunOnYourOwn/TurfTrack/go-app/||')
              SUMMARY+="| \`${SHORT}\` | ${COV} |\n"
            fi
          done < <(grep "^ok" integration-test-output.txt 2>/dev/null)

          printf '%b' "$SUMMARY" >> $GITHUB_STEP_SUMMARY

      - name: Cleanup workspace
        if: always()
        run: rm -rf $GITHUB_WORKSPACE/*

  # Final status check
  ci-status:
    needs: [test-go, test-integration]
    if: always()
    runs-on: [self-hosted, Linux]
    permissions:
      contents: read
      actions: read
      pull-requests: write
    steps:
      - name: Update PR comment with CI status
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const runId = context.runId;
            const runUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${runId}`;

            // Fetch jobs for this workflow run to get individual job URLs
            const { data: jobsData } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId,
            });

            const jobs = jobsData.jobs;

            const checks = [
              {
                jobName: 'test-go',
                displayName: 'Go Unit Tests & Lint',
                result: '${{ needs.test-go.result }}'
              },
              {
                jobName: 'test-integration',
                displayName: 'Go Integration Tests',
                result: '${{ needs.test-integration.result }}'
              }
            ];

            let comment = `## CI/CD Status\n\n`;
            comment += `All checks must pass before merging to main:\n\n`;

            let allPassed = true;

            for (const check of checks) {
              const job = jobs.find(j => j.name === check.jobName);
              const jobUrl = job ? job.html_url : runUrl;

              let icon = '';
              let checkbox = '[ ]';

              if (check.result === 'success') {
                icon = 'PASS';
                checkbox = '[x]';
              } else if (check.result === 'failure') {
                icon = 'FAIL';
                checkbox = '[ ]';
                allPassed = false;
              } else if (check.result === 'cancelled') {
                icon = 'CANCELLED';
                checkbox = '[ ]';
                allPassed = false;
              } else if (check.result === 'skipped') {
                icon = 'SKIPPED';
                checkbox = '[ ]';
              }

              comment += `- ${checkbox} ${icon} **${check.displayName}** - [View Details](${jobUrl})\n`;
            }

            const overallStatus = allPassed ? 'All Checks Passed' : 'Some Checks Failed';
            comment += `\n**Overall Status**: ${overallStatus}\n`;
            comment += `\n[View Full CI Run](${runUrl})`;

            // Find existing CI comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c => c.user.type === 'Bot' && c.body.includes('CI/CD Status'));

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment,
              });
              console.log('Updated existing PR comment');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment,
              });
              console.log('Created new PR comment');
            }

      - name: Check CI status
        run: |
          if [[ "${{ needs.test-go.result }}" == "failure" || \
                "${{ needs.test-integration.result }}" == "failure" ]]; then
            echo "CI pipeline failed"
            exit 1
          fi
          echo "CI pipeline passed"

      - name: Cleanup workspace
        if: always()
        run: |
          echo "Cleaning up workspace for self-hosted runner..."
          rm -rf $GITHUB_WORKSPACE/*
          echo "Workspace cleaned"

  # Deploy documentation to GitHub Pages
  deploy-docs:
    needs: [test-go, test-integration]
    name: Deploy Documentation
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pages: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: npm
          cache-dependency-path: docs/package-lock.json

      - name: Install dependencies
        working-directory: docs
        run: npm ci

      - name: Build documentation site
        working-directory: docs
        run: npm run docs:build

      - name: Setup Pages
        uses: actions/configure-pages@v5

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: docs/.vitepress/dist

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
