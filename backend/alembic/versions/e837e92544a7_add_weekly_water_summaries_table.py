"""add_weekly_water_summaries_table

Revision ID: e837e92544a7
Revises: 690dabfeedbd
Create Date: 2025-08-10 15:26:38.919422

"""

from typing import Sequence, Union
from datetime import date, timedelta
from sqlalchemy import text

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = "e837e92544a7"
down_revision: Union[str, None] = "690dabfeedbd"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table(
        "weekly_water_summaries",
        sa.Column("id", sa.Integer(), autoincrement=True, nullable=False),
        sa.Column("lawn_id", sa.Integer(), nullable=False),
        sa.Column("week_start", sa.Date(), nullable=False),
        sa.Column("week_end", sa.Date(), nullable=False),
        sa.Column("et0_total", sa.Float(), nullable=False),
        sa.Column("precipitation_total", sa.Float(), nullable=False),
        sa.Column("irrigation_applied", sa.Float(), nullable=False),
        sa.Column("water_deficit", sa.Float(), nullable=False),
        sa.Column("status", sa.String(length=20), nullable=False),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=False),
        sa.ForeignKeyConstraint(["lawn_id"], ["lawns.id"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_index(
        op.f("ix_weekly_water_summaries_week_end"),
        "weekly_water_summaries",
        ["week_end"],
        unique=False,
    )
    op.create_index(
        op.f("ix_weekly_water_summaries_week_start"),
        "weekly_water_summaries",
        ["week_start"],
        unique=False,
    )
    op.create_unique_constraint(
        "uix_lawn_week_start", "weekly_water_summaries", ["lawn_id", "week_start"]
    )
    # ### end Alembic commands ###

    # Populate weekly water summaries with existing data
    # This calculates weekly summaries for all lawns based on existing weather and irrigation data
    connection = op.get_bind()

    # Get all lawns
    lawns_result = connection.execute(text("SELECT id, location_id FROM lawns"))
    lawns = lawns_result.fetchall()

    for lawn in lawns:
        lawn_id = lawn[0]
        location_id = lawn[1]

        # Get the date range for this lawn (last 8 weeks)
        today = date.today()
        start_date = today - timedelta(weeks=8)

        # Calculate weekly summaries
        # For each week, aggregate weather data and irrigation data
        current_date = start_date
        while current_date <= today:
            # Calculate week start (Monday)
            days_since_monday = current_date.weekday()
            week_start = current_date - timedelta(days=days_since_monday)
            week_end = week_start + timedelta(days=6)

            # Skip if week_end is beyond today
            if week_start > today:
                break

            # Get weather data for the week
            weather_query = text("""
                SELECT 
                    COALESCE(SUM(et0_evapotranspiration_in), 0) as et0_total,
                    COALESCE(SUM(precipitation_in), 0) as precipitation_total
                FROM daily_weather 
                WHERE location_id = :location_id 
                AND date >= :week_start 
                AND date <= :week_end
            """)

            weather_result = connection.execute(
                weather_query,
                {
                    "location_id": location_id,
                    "week_start": week_start,
                    "week_end": week_end,
                },
            )
            weather_data = weather_result.fetchone()

            # Get irrigation data for the week
            irrigation_query = text("""
                SELECT COALESCE(SUM(amount), 0) as irrigation_applied
                FROM irrigation_entries 
                WHERE lawn_id = :lawn_id 
                AND date >= :week_start 
                AND date <= :week_end
            """)

            irrigation_result = connection.execute(
                irrigation_query,
                {"lawn_id": lawn_id, "week_start": week_start, "week_end": week_end},
            )
            irrigation_data = irrigation_result.fetchone()

            # Calculate water deficit and status
            et0_total = weather_data[0] if weather_data else 0.0
            precipitation_total = weather_data[1] if weather_data else 0.0
            irrigation_applied = irrigation_data[0] if irrigation_data else 0.0
            water_deficit = et0_total - precipitation_total - irrigation_applied

            # Determine status
            if water_deficit <= 0:
                status = "excellent"
            elif water_deficit <= 0.5:
                status = "good"
            elif water_deficit <= 1.0:
                status = "warning"
            else:
                status = "critical"

            # Insert the weekly summary
            insert_query = text("""
                INSERT INTO weekly_water_summaries 
                (lawn_id, week_start, week_end, et0_total, precipitation_total, 
                 irrigation_applied, water_deficit, status, created_at, updated_at)
                VALUES 
                (:lawn_id, :week_start, :week_end, :et0_total, :precipitation_total,
                 :irrigation_applied, :water_deficit, :status, NOW(), NOW())
                ON CONFLICT (lawn_id, week_start) DO NOTHING
            """)

            connection.execute(
                insert_query,
                {
                    "lawn_id": lawn_id,
                    "week_start": week_start,
                    "week_end": week_end,
                    "et0_total": et0_total,
                    "precipitation_total": precipitation_total,
                    "irrigation_applied": irrigation_applied,
                    "water_deficit": water_deficit,
                    "status": status,
                },
            )

            # Move to next week
            current_date = week_start + timedelta(days=7)


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_unique_constraint("uix_lawn_week_start", "weekly_water_summaries")
    op.drop_index(
        op.f("ix_weekly_water_summaries_week_start"),
        table_name="weekly_water_summaries",
    )
    op.drop_index(
        op.f("ix_weekly_water_summaries_week_end"), table_name="weekly_water_summaries"
    )
    op.drop_table("weekly_water_summaries")
    # ### end Alembic commands ###
